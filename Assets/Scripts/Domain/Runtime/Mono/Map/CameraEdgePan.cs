using UnityEngine;

namespace Project
{
    // THIS CODE WAS GENERATED BY AI, SINCE I AM TOO FUCKING LAZY TO THINK ABOUT CAM MOVEMENT
    public class CameraEdgePan : MonoBehaviour
    {
        [Header("Edge Movement Settings")]
        [SerializeField] private bool enableEdgeMovement = true;
        [SerializeField] private float edgeMovementSpeed = 5f;
        [SerializeField] private EdgeDetectionMode edgeDetectionMode = EdgeDetectionMode.SCREEN_PERCENTAGE;
        [SerializeField] private float edgeThreshold = 0.05f;
        [SerializeField] private int edgeThresholdPixels = 20;

        [Header("Movement Axes")]
        [SerializeField] private bool allowHorizontalMovement = true;
        [SerializeField] private bool allowVerticalMovement = true;

        [Header("Speed Curve")]
        [SerializeField] private SpeedCurveType speedCurveType = SpeedCurveType.LINEAR;
        [SerializeField] private AnimationCurve customSpeedCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

        [Header("Camera Bounds")]
        [SerializeField] private bool enableBounds = true;
        [SerializeField] private Vector2 boundsMin = new Vector2(-10f, -10f);
        [SerializeField] private Vector2 boundsMax = new Vector2(10f, 10f);

        [Header("Smoothing")]
        [SerializeField] private bool enableSmoothing = true;
        [SerializeField] private float smoothTime = 0.2f;

        [Header("Editor Visualization")]
        [SerializeField] private bool showEdgeZonesInEditor = true;
        [SerializeField] private Color edgeZoneColor = new Color(1f, 0f, 0f, 0.3f);
        [SerializeField] private bool showBoundsInEditor = true;
        [SerializeField] private Color boundsColor = Color.green;

        [SerializeField] private Camera cam;
        private Vector3 velocity = Vector3.zero;

        public enum EdgeDetectionMode
        {
            SCREEN_PERCENTAGE,
            PIXELS
        }

        public enum SpeedCurveType
        {
            LINEAR,
            QUADRATIC,
            EXPONENTIAL,
            CUSTOM
        }

        // Properties for runtime adjustment
        public bool EnableEdgeMovement { get => enableEdgeMovement; set => enableEdgeMovement = value; }
        public bool EnableBounds { get => enableBounds; set => enableBounds = value; }
        public bool AllowHorizontalMovement { get => allowHorizontalMovement; set => allowHorizontalMovement = value; }
        public bool AllowVerticalMovement { get => allowVerticalMovement; set => allowVerticalMovement = value; }

        void Start()
        {
            // Initialize default custom curve if not set
            if (customSpeedCurve == null || customSpeedCurve.length == 0)
            {
                customSpeedCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));
            }
        }

        void Update()
        {
            if (enableEdgeMovement)
            {
                HandleEdgeMovement();
            }
        }

        private void HandleEdgeMovement()
        {
            Vector2 mousePosition = Input.mousePosition;
            Vector3 moveDirection = Vector3.zero;

            // Calculate screen edges based on settings
            float leftEdge, rightEdge, bottomEdge, topEdge;

            if (edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE)
            {
                leftEdge = Screen.width * edgeThreshold;
                rightEdge = Screen.width * (1f - edgeThreshold);
                bottomEdge = Screen.height * edgeThreshold;
                topEdge = Screen.height * (1f - edgeThreshold);
            }
            else // PIXELS mode
            {
                leftEdge = edgeThresholdPixels;
                rightEdge = Screen.width - edgeThresholdPixels;
                bottomEdge = edgeThresholdPixels;
                topEdge = Screen.height - edgeThresholdPixels;
            }

            // Check horizontal movement
            if (allowHorizontalMovement)
            {
                if (mousePosition.x <= leftEdge)
                {
                    float distanceFromEdge = leftEdge - mousePosition.x;
                    float maxDistance = edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE ?
                        Screen.width * edgeThreshold : edgeThresholdPixels;

                    float normalizedDistance = Mathf.Clamp01(distanceFromEdge / maxDistance);
                    float speedMultiplier = CalculateSpeedMultiplier(normalizedDistance);

                    moveDirection.x = -speedMultiplier;
                }
                else if (mousePosition.x >= rightEdge)
                {
                    float distanceFromEdge = mousePosition.x - rightEdge;
                    float maxDistance = edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE ?
                        Screen.width * edgeThreshold : edgeThresholdPixels;

                    float normalizedDistance = Mathf.Clamp01(distanceFromEdge / maxDistance);
                    float speedMultiplier = CalculateSpeedMultiplier(normalizedDistance);

                    moveDirection.x = speedMultiplier;
                }
            }

            // Check vertical movement
            if (allowVerticalMovement)
            {
                if (mousePosition.y <= bottomEdge)
                {
                    float distanceFromEdge = bottomEdge - mousePosition.y;
                    float maxDistance = edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE ?
                        Screen.height * edgeThreshold : edgeThresholdPixels;

                    float normalizedDistance = Mathf.Clamp01(distanceFromEdge / maxDistance);
                    float speedMultiplier = CalculateSpeedMultiplier(normalizedDistance);

                    moveDirection.y = -speedMultiplier;
                }
                else if (mousePosition.y >= topEdge)
                {
                    float distanceFromEdge = mousePosition.y - topEdge;
                    float maxDistance = edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE ?
                        Screen.height * edgeThreshold : edgeThresholdPixels;

                    float normalizedDistance = Mathf.Clamp01(distanceFromEdge / maxDistance);
                    float speedMultiplier = CalculateSpeedMultiplier(normalizedDistance);

                    moveDirection.y = speedMultiplier;
                }
            }

            // Apply movement
            if (moveDirection != Vector3.zero)
            {
                Vector3 targetPosition = transform.position + moveDirection * edgeMovementSpeed * Time.deltaTime;

                // Apply bounds
                if (enableBounds)
                {
                    targetPosition = ApplyBounds(targetPosition);
                }

                // Apply smoothing or direct movement
                if (enableSmoothing)
                {
                    transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, smoothTime);
                }
                else
                {
                    transform.position = targetPosition;
                }
            }
        }

        private float CalculateSpeedMultiplier(float normalizedDistance)
        {
            switch (speedCurveType)
            {
                case SpeedCurveType.LINEAR:
                    return normalizedDistance;

                case SpeedCurveType.QUADRATIC:
                    return normalizedDistance * normalizedDistance;

                case SpeedCurveType.EXPONENTIAL:
                    return Mathf.Pow(normalizedDistance, 0.5f);

                case SpeedCurveType.CUSTOM:
                    return customSpeedCurve.Evaluate(normalizedDistance);

                default:
                    return normalizedDistance;
            }
        }

        private Vector3 ApplyBounds(Vector3 targetPosition)
        {
            if (cam == null) return targetPosition;

            // Calculate camera's viewport size in world units
            float height = cam.orthographicSize * 2f;
            float width = height * cam.aspect;

            Vector2 halfSize = new Vector2(width / 2f, height / 2f);

            // Clamp position within bounds
            targetPosition.x = Mathf.Clamp(targetPosition.x, boundsMin.x + halfSize.x, boundsMax.x - halfSize.x);
            targetPosition.y = Mathf.Clamp(targetPosition.y, boundsMin.y + halfSize.y, boundsMax.y - halfSize.y);

            return targetPosition;
        }
        // Visualize in Scene view only
        private void OnDrawGizmos()
        {
            if (!showEdgeZonesInEditor && !showBoundsInEditor) return;

            // Draw edge zones - теперь привязаны к игровой камере
            if (showEdgeZonesInEditor && enableEdgeMovement)
            {
                DrawEdgeZonesGizmos();
            }

            // Draw bounds
            if (showBoundsInEditor && enableBounds)
            {
                DrawBoundsGizmos();
            }
        }

        private void DrawEdgeZonesGizmos()
        {
            // Используем нашу игровую камеру, а не камеру редактора
            //Camera gameCam = GetComponentInChildren<Camera>();
            Camera gameCam = cam;
            if (gameCam == null) return;

            // Рассчитываем границы видимости игровой камеры в мировых координатах
            float height = gameCam.orthographicSize * 2f;
            float width = height * gameCam.aspect;

            Vector3 cameraPos = transform.position;
            Vector3 bottomLeft = new Vector3(cameraPos.x - width / 2f, cameraPos.y - height / 2f, cameraPos.z);
            Vector3 topRight = new Vector3(cameraPos.x + width / 2f, cameraPos.y + height / 2f, cameraPos.z);

            // Рассчитываем размеры зон краев в мировых координатах
            float edgeZoneWidth = 0f;
            float edgeZoneHeight = 0f;

            if (edgeDetectionMode == EdgeDetectionMode.SCREEN_PERCENTAGE)
            {
                edgeZoneWidth = width * edgeThreshold;
                edgeZoneHeight = height * edgeThreshold;
            }
            else // PIXELS mode - конвертируем пиксели в мировые единицы
            {
                // Предполагаем, что пиксели соотносятся с мировыми единицами через orthographicSize
                float pixelsPerUnit = Screen.height / (gameCam.orthographicSize * 2f);
                edgeZoneWidth = edgeThresholdPixels / pixelsPerUnit;
                edgeZoneHeight = edgeThresholdPixels / pixelsPerUnit;
            }

            Gizmos.color = edgeZoneColor;

            // Рисуем горизонтальные зоны краев
            if (allowHorizontalMovement)
            {
                // Левая зона
                Vector3 leftZoneCenter = new Vector3(
                    bottomLeft.x + edgeZoneWidth / 2f,
                    cameraPos.y,
                    cameraPos.z
                );
                Vector3 leftZoneSize = new Vector3(edgeZoneWidth, height, 0.1f);
                Gizmos.DrawCube(leftZoneCenter, leftZoneSize);

                // Правая зона
                Vector3 rightZoneCenter = new Vector3(
                    topRight.x - edgeZoneWidth / 2f,
                    cameraPos.y,
                    cameraPos.z
                );
                Vector3 rightZoneSize = new Vector3(edgeZoneWidth, height, 0.1f);
                Gizmos.DrawCube(rightZoneCenter, rightZoneSize);
            }

            // Рисуем вертикальные зоны краев
            if (allowVerticalMovement)
            {
                // Нижняя зона
                Vector3 bottomZoneCenter = new Vector3(
                    cameraPos.x,
                    bottomLeft.y + edgeZoneHeight / 2f,
                    cameraPos.z
                );
                Vector3 bottomZoneSize = new Vector3(width, edgeZoneHeight, 0.1f);
                Gizmos.DrawCube(bottomZoneCenter, bottomZoneSize);

                // Верхняя зона
                Vector3 topZoneCenter = new Vector3(
                    cameraPos.x,
                    topRight.y - edgeZoneHeight / 2f,
                    cameraPos.z
                );
                Vector3 topZoneSize = new Vector3(width, edgeZoneHeight, 0.1f);
                Gizmos.DrawCube(topZoneCenter, topZoneSize);
            }

            // Дополнительно: рисуем контуры для лучшей видимости
            Gizmos.color = new Color(edgeZoneColor.r, edgeZoneColor.g, edgeZoneColor.b, 1f);

            if (allowHorizontalMovement)
            {
                // Контур левой зоны
                Vector3 leftZoneCenter = new Vector3(bottomLeft.x + edgeZoneWidth / 2f, cameraPos.y, cameraPos.z);
                Vector3 leftZoneSize = new Vector3(edgeZoneWidth, height, 0.1f);
                Gizmos.DrawWireCube(leftZoneCenter, leftZoneSize);

                // Контур правой зоны
                Vector3 rightZoneCenter = new Vector3(topRight.x - edgeZoneWidth / 2f, cameraPos.y, cameraPos.z);
                Vector3 rightZoneSize = new Vector3(edgeZoneWidth, height, 0.1f);
                Gizmos.DrawWireCube(rightZoneCenter, rightZoneSize);
            }

            if (allowVerticalMovement)
            {
                // Контур нижней зоны
                Vector3 bottomZoneCenter = new Vector3(cameraPos.x, bottomLeft.y + edgeZoneHeight / 2f, cameraPos.z);
                Vector3 bottomZoneSize = new Vector3(width, edgeZoneHeight, 0.1f);
                Gizmos.DrawWireCube(bottomZoneCenter, bottomZoneSize);

                // Контур верхней зоны
                Vector3 topZoneCenter = new Vector3(cameraPos.x, topRight.y - edgeZoneHeight / 2f, cameraPos.z);
                Vector3 topZoneSize = new Vector3(width, edgeZoneHeight, 0.1f);
                Gizmos.DrawWireCube(topZoneCenter, topZoneSize);
            }
        }

        private void DrawBoundsGizmos()
        {
            Gizmos.color = boundsColor;
            Vector3 center = new Vector3((boundsMin.x + boundsMax.x) / 2f, (boundsMin.y + boundsMax.y) / 2f, 0f);
            Vector3 size = new Vector3(boundsMax.x - boundsMin.x, boundsMax.y - boundsMin.y, 0.1f);
            Gizmos.DrawWireCube(center, size);

            // Дополнительно: заливка для границ
            Gizmos.color = new Color(boundsColor.r, boundsColor.g, boundsColor.b, 0.1f);
            Gizmos.DrawCube(center, size);
        }

        // Method to set bounds programmatically
        public void SetBounds(Vector2 min, Vector2 max)
        {
            if (min != null)
            { boundsMin = min; }
            if (max != null)
            { boundsMax = max; }
        }

        // Method to get current bounds
        public Rect GetCurrentBounds()
        {
            return new Rect(boundsMin, boundsMax - boundsMin);
        }

        // Method to check if a position is within bounds
        public bool IsWithinBounds(Vector3 position)
        {
            if (cam == null) return true;

            float height = cam.orthographicSize * 2f;
            float width = height * cam.aspect;
            Vector2 halfSize = new Vector2(width / 2f, height / 2f);

            return position.x >= boundsMin.x + halfSize.x &&
                   position.x <= boundsMax.x - halfSize.x &&
                   position.y >= boundsMin.y + halfSize.y &&
                   position.y <= boundsMax.y - halfSize.y;
        }

        // Runtime methods to change settings
        public void SetEdgeDetectionMode(EdgeDetectionMode mode)
        {
            edgeDetectionMode = mode;
        }

        public void SetSpeedCurveType(SpeedCurveType curveType)
        {
            speedCurveType = curveType;
        }

        public void SetEdgeThreshold(float threshold)
        {
            edgeThreshold = Mathf.Clamp01(threshold);
        }

        public void SetEdgeThresholdPixels(int pixels)
        {
            edgeThresholdPixels = Mathf.Max(0, pixels);
        }

        // Toggle visualization at runtime
        public void ToggleEdgeZoneVisualization(bool show)
        {
            showEdgeZonesInEditor = show;
        }

        public void ToggleBoundsVisualization(bool show)
        {
            showBoundsInEditor = show;
        }
    }
}
